<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Light Maze</title>
<style>
    body {
        margin: 0;
        background: #0b0b0f;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        font-family: 'Courier New', monospace;
        color: #fff;
    }
    canvas {
        background: #111;
        border: 2px solid #fff;
        border-radius: 10px;
    }
    #info {
        position: absolute;
        top: 10px;
        text-align: center;
        width: 100%;
        color: #0ff;
    }
</style>
</head>
<body>
<div id="info">Click mirrors to rotate and guide the beam to the goal!</div>
<canvas id="gameCanvas" width="600" height="600"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const gridSize = 6; // 6x6 grid
const cellSize = canvas.width / gridSize;

// Game objects
let mirrors = [
    {x: 2, y: 2, dir: 0}, // dir = 0 ( / ), 1 = \ 
    {x: 4, y: 3, dir: 1},
];
let goal = {x: 5, y: 5};
let beamPath = [];

function drawGrid() {
    ctx.strokeStyle = '#333';
    for (let i = 0; i <= gridSize; i++) {
        ctx.beginPath();
        ctx.moveTo(i*cellSize, 0);
        ctx.lineTo(i*cellSize, canvas.height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i*cellSize);
        ctx.lineTo(canvas.width, i*cellSize);
        ctx.stroke();
    }
}

function drawMirrors() {
    mirrors.forEach(m => {
        ctx.save();
        ctx.translate(m.x*cellSize + cellSize/2, m.y*cellSize + cellSize/2);
        ctx.rotate(m.dir * Math.PI/2);
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(-cellSize/2 + 10, -cellSize/2 + 10);
        ctx.lineTo(cellSize/2 - 10, cellSize/2 - 10);
        ctx.stroke();
        ctx.restore();
    });
}

function drawGoal() {
    ctx.fillStyle = '#ff0';
    ctx.beginPath();
    ctx.arc(goal.x*cellSize + cellSize/2, goal.y*cellSize + cellSize/2, cellSize/3, 0, Math.PI*2);
    ctx.fill();
}

function castBeam() {
    beamPath = [];
    let x = 0.5;
    let y = 0.5;
    let dx = 1;
    let dy = 0;
    let maxSteps = 100;
    
    for (let i = 0; i < maxSteps; i++) {
        beamPath.push({x, y});
        
        let gridX = Math.floor(x);
        let gridY = Math.floor(y);
        
        if (gridX === goal.x && gridY === goal.y) break;
        
        let mirror = mirrors.find(m => m.x === gridX && m.y === gridY);
        if (mirror) {
            if (mirror.dir === 0) {
                // / mirror
                [dx, dy] = [-dy, -dx];
            } else {
                // \ mirror
                [dx, dy] = [dy, dx];
            }
        }
        
        x += dx*0.1;
        y += dy*0.1;
        
        if (x < 0 || y < 0 || x > gridSize || y > gridSize) break;
    }
}

function drawBeam() {
    ctx.strokeStyle = '#0f0';
    ctx.lineWidth = 4;
    ctx.beginPath();
    beamPath.forEach((p, i) => {
        let px = p.x * cellSize;
        let py = p.y * cellSize;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
    });
    ctx.stroke();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawGrid();
    drawGoal();
    drawMirrors();
    castBeam();
    drawBeam();
}

canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const gridX = Math.floor(mx / cellSize);
    const gridY = Math.floor(my / cellSize);
    
    const mirror = mirrors.find(m => m.x === gridX && m.y === gridY);
    if (mirror) {
        mirror.dir = (mirror.dir + 1) % 2;
        draw();
    }
});

draw();
</script>
</body>
</html>
